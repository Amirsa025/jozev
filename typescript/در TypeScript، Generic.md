در TypeScript، **Generic** یا عمومی‌سازی، ابزاری قدرتمند است که به شما اجازه می‌دهد کدهایی بنویسید که انعطاف‌پذیر و قابل استفاده مجدد باشند، در حالی که همچنان نوع‌داده‌ها (Type Safety) را حفظ می‌کنند. با استفاده از Generic، می‌توانید توابع، کلاس‌ها یا رابط‌هایی تعریف کنید که با انواع مختلفی از داده‌ها کار کنند، بدون اینکه نیاز باشد برای هر نوع داده کد جداگانه‌ای بنویسید.

### مفهوم Generic
به زبان ساده، Generic به شما اجازه می‌دهد یک "متغیر نوع" (Type Variable) تعریف کنید که بعداً مشخص می‌شود با چه نوع داده‌ای کار می‌کند. این متغیر نوع معمولاً با یک حرف مثل `T` یا `U` نشان داده می‌شود.

### مثال ساده: تابع Generic
فرض کنید می‌خواهیم تابعی بنویسیم که یک آرایه را بگیرد و همان آرایه را برگرداند. بدون Generic، ممکن است مجبور شویم برای هر نوع داده (مثل `string` یا `number`) تابع جداگانه‌ای بنویسیم. اما با Generic این کار ساده‌تر می‌شود:

```typescript
function getArray<T>(items: T[]): T[] {
    return items;
}

// استفاده از تابع
const numbers = getArray<number>([1, 2, 3]); // آرایه‌ای از اعداد
const strings = getArray<string>(["سلام", "جهان"]); // آرایه‌ای از رشته‌ها
```

در اینجا:
- `<T>` یک متغیر نوع است که نوع داده را مشخص می‌کند.
- وقتی تابع را صدا می‌زنیم، نوع داده را داخل `<>` می‌نویسیم (مثل `<number>` یا `<string>`).
- TypeScript به صورت خودکار نوع خروجی را بر اساس ورودی تشخیص می‌دهد (Type Inference)، پس حتی می‌توانیم `<number>` را حذف کنیم:

```typescript
const numbers = getArray([1, 2, 3]); // همچنان کار می‌کند
```

### مثال کاربردی: جعبه Generic
فرض کنید می‌خواهیم یک کلاس بسازیم که یک مقدار را نگه دارد و بتوانیم نوع آن مقدار را مشخص کنیم:

```typescript
class Box<T> {
    private content: T;

    constructor(value: T) {
        this.content = value;
    }

    getContent(): T {
        return this.content;
    }

    setContent(value: T): void {
        this.content = value;
    }
}

// استفاده از کلاس
const numberBox = new Box<number>(123);
console.log(numberBox.getContent()); // خروجی: 123

const stringBox = new Box<string>("سلام");
console.log(stringBox.getContent()); // خروجی: "سلام"
```

در این مثال:
- کلاس `Box` با استفاده از `<T>` تعریف شده و می‌تواند هر نوع داده‌ای را نگه دارد.
- وقتی یک شیء از این کلاس می‌سازیم، نوع داده را مشخص می‌کنیم (مثل `Box<number>` یا `Box<string>`).

### مثال پیشرفته‌تر: تابع با محدودیت Generic
گاهی نیاز داریم که نوع Generic ما محدودیت‌هایی داشته باشد. مثلاً فقط با اشیایی کار کند که یک ویژگی خاص (مثل `name`) دارند. برای این کار از کلیدواژه `extends` استفاده می‌کنیم:

```typescript
interface Named {
    name: string;
}

function printName<T extends Named>(item: T): void {
    console.log(item.name);
}

// استفاده از تابع
const person = { name: "علی", age: 25 };
const car = { name: "پراید" };

printName(person); // خروجی: "علی"
printName(car);    // خروجی: "پراید"
// printName(123); // خطا! چون عدد ویژگی name ندارد
```

در اینجا:
- `<T extends Named>` یعنی `T` باید حتماً یک شیء باشد که ویژگی `name` از نوع `string` داشته باشد.
- این کار باعث می‌شود که TypeScript خطاهایی را که ممکن است به خاطر نوع نادرست رخ دهد، در زمان کامپایل تشخیص دهد.

### چرا Generic مهم است؟
1. **استفاده مجدد از کد**: یک تابع یا کلاس می‌تواند با انواع مختلف داده کار کند.
2. **ایمنی نوع (Type Safety)**: TypeScript مطمئن می‌شود که نوع داده‌ها درست استفاده شوند.
3. **انعطاف‌پذیری**: بدون نیاز به نوشتن کد تکراری، می‌توانید با هر نوع داده‌ای کار کنید.

### جمع‌بندی
Generic در TypeScript مثل یک قالب انعطاف‌پذیر است که می‌توانید آن را با هر نوع داده‌ای پر کنید. از مثال‌های بالا می‌بینید که هم در توابع ساده، هم در کلاس‌ها و هم در موارد پیچیده‌تر با محدودیت‌ها، Generic به ما کمک می‌کند کدی تمیزتر و قابل نگهداری‌تر بنویسیم.
