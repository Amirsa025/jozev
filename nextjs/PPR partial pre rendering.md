
##  مفهوم PPR: یک ویژگی جدید و آزمایشی است که در Next.js 15 معرفی شده است .

1. معرفی PPR:
Partial Pre-rendering به شما امکان می‌دهد اجزای استاتیک و پویا را در یک مسیر (route) ترکیب کنید .
2. هدف PPR:
هدف اصلی PPR، ترکیب مزایای رندرینگ استاتیک و پویا است .
1. نحوه کارکرد:

2. در زمان ساخت (build time)، Next.js تا حد امکان از مسیر را پیش‌رندر می‌کند.
3. اگر کد پویا تشخیص داده شود (مانند خواندن از درخواست ورودی)، می‌توانید کامپوننت مربوطه را با یک مرز React Suspense بپیچید .



4. پذیرش تدریجی در Next.js 15:

5. برای استفاده از PPR، باید گزینه `ppr` را در `next.config.js` به `'incremental'` تنظیم کنید.
6. همچنین باید گزینه پیکربندی مسیر `experimental_ppr` را در بالای فایل صادر کنید .



7. نحوه پیکربندی:
در `next.config.js`:

```javascript
const nextConfig = {
  experimental: {
    ppr: 'incremental',
  },
};

export default nextConfig;
```

در فایل مسیر (مثلاً `app/page.tsx`):

```javascript
export const experimental_ppr = true;

export default function Page() {
  // ...
}
```


8. نکات مهم:

9. مسیرهایی که `experimental_ppr` ندارند، به طور پیش‌فرض از PPR استفاده نمی‌کنند.
10. `experimental_ppr` برای تمام فرزندان بخش مسیر اعمال می‌شود، از جمله لایه‌ها و صفحات تودرتو.
11. برای غیرفعال کردن PPR برای بخش‌های فرزند، می‌توانید `experimental_ppr` را در بخش فرزند به `false` تنظیم کنید .



12. وضعیت فعلی:
PPR هنوز یک ویژگی آزمایشی است و ممکن است تغییر کند. برای استفاده در محیط تولید توصیه نمی‌شود .


بسیار خوب، اجازه دهید جزئیات بیشتری در مورد Partial Pre-rendering (PPR) در Next.js 15 ارائه دهم:

13. مزایای PPR:

14. بهبود عملکرد: با ترکیب رندرینگ استاتیک و پویا، PPR می‌تواند زمان بارگذاری اولیه را کاهش دهد .
15. انعطاف‌پذیری: به شما امکان می‌دهد بخش‌های استاتیک و پویا را در یک صفحه داشته باشید .



16. نحوه کار PPR در پشت صحنه:

17. در زمان ساخت، Next.js یک نسخه استاتیک از صفحه را ایجاد می‌کند.
18. برای بخش‌های پویا، یک placeholder در HTML اولیه قرار می‌دهد.
19. در زمان اجرا، بخش‌های پویا به صورت تدریجی بارگذاری و رندر می‌شوند .



20. استفاده از Suspense با PPR:
برای بخش‌های پویا، از Suspense استفاده می‌کنید:

```javascriptreact
import { Suspense } from 'react';
import { DynamicComponent } from './DynamicComponent';

export const experimental_ppr = true;

export default function Page() {
  return (
    <>
      <h1>This will be pre-rendered</h1>
      <Suspense fallback={<p>Loading...</p>}>
        <DynamicComponent />
      </Suspense>
    </>
  );
}
```


21. محدودیت‌ها و نکات:

22. PPR فقط در حالت تولید (production) کار می‌کند، نه در حالت توسعه (development) .
23. در حال حاضر، PPR با برخی ویژگی‌های Next.js مانند `getStaticProps` و `getServerSideProps` سازگار نیست .



24. مقایسه با رویکردهای قبلی:

25. برخلاف SSG یا SSR، PPR اجازه می‌دهد بخش‌هایی از صفحه استاتیک و بخش‌های دیگر پویا باشند .
26. این رویکرد می‌تواند جایگزینی برای ISR (Incremental Static Regeneration) در برخی موارد باشد .



27. بهینه‌سازی عملکرد:

28. PPR می‌تواند به طور قابل توجهی Time to First Byte (TTFB) را بهبود بخشد، زیرا بخش‌های استاتیک فوراً ارسال می‌شوند .
29. بخش‌های پویا می‌توانند به صورت موازی بارگذاری شوند، که باعث بهبود عملکرد کلی می‌شود .



30. دیباگ کردن PPR:

31. Next.js ابزارهایی برای دیباگ PPR ارائه می‌دهد، از جمله لاگ‌های خاص که نشان می‌دهند کدام بخش‌ها به صورت استاتیک و کدام به صورت پویا رندر شده‌اند .



32. آینده PPR:

33. انتظار می‌رود که PPR در نسخه‌های آینده Next.js بهبود یابد و ویژگی‌های بیشتری به آن اضافه شود .


==========================================================

با توجه به اینکه شما علاقه‌مند به اطلاعات بیشتر هستید، اجازه دهید به برخی از جنبه‌های پیشرفته‌تر و کاربردی‌تر Partial Pre-rendering (PPR) در Next.js 15 بپردازیم:


1. استراتژی‌های بهینه‌سازی با PPR:

2. تقسیم‌بندی محتوا: محتوای استاتیک را در بالای صفحه قرار دهید تا First Contentful Paint (FCP) را بهبود بخشید .
3. استفاده از Streaming SSR: PPR را می‌توان با Streaming SSR ترکیب کرد تا عملکرد را بیشتر بهبود بخشید .



4. مدیریت حالت (State Management) با PPR:

5. برای کامپوننت‌های پویا، می‌توانید از هوک‌های React مانند `useState` و `useEffect` استفاده کنید.
6. برای مدیریت حالت در سطح برنامه، می‌توانید از ابزارهایی مانند Redux یا Recoil استفاده کنید که با PPR سازگار هستند.



7. کار با API Routes و PPR:

8. API Routes همچنان به صورت پویا کار می‌کنند و می‌توانند با کامپوننت‌های پویا در PPR استفاده شوند.
9. می‌توانید از `fetch` در کامپوننت‌های سرور برای درخواست‌های API استفاده کنید .



10. SEO و PPR:

11. بخش‌های استاتیک صفحه برای موتورهای جستجو قابل مشاهده خواهند بود.
12. برای محتوای پویا، می‌توانید از تکنیک‌های مانند Dynamic Rendering استفاده کنید تا SEO را بهبود بخشید.



13. تست و CI/CD با PPR:

14. تست‌های واحد: کامپوننت‌های استاتیک و پویا را جداگانه تست کنید.
15. تست‌های یکپارچگی: اطمینان حاصل کنید که کامپوننت‌های استاتیک و پویا به درستی با هم کار می‌کنند.
16. در CI/CD، اطمینان حاصل کنید که PPR در محیط تولید به درستی فعال شده است.



17. مدیریت خطا در PPR:

18. استفاده از Error Boundaries برای مدیریت خطاهای کامپوننت‌های پویا:


```javascriptreact
import { ErrorBoundary } from 'react-error-boundary';

export default function Page() {
  return (
    <>
      <StaticComponent />
      <ErrorBoundary fallback={<ErrorFallback />}>
        <Suspense fallback={<Loading />}>
          <DynamicComponent />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}
```


19. استفاده از PPR با TypeScript:

20. TypeScript با PPR سازگار است. می‌توانید از type annotations برای کامپوننت‌های استاتیک و پویا استفاده کنید.



21. پرفورمنس مانیتورینگ با PPR:

22. استفاده از ابزارهای مانند Lighthouse و Web Vitals برای اندازه‌گیری تأثیر PPR بر عملکرد سایت.
23. مانیتور کردن متریک‌های خاص مانند Time to Interactive (TTI) و Largest Contentful Paint (LCP).



24. استفاده از PPR با CDN‌ها:


25. PPR با CDN‌ها سازگار است. بخش‌های استاتیک می‌توانند در edge caches ذخیره شوند، در حالی که بخش‌های پویا از سرور اصلی درخواست می‌شوند.
==========================================================
سلام! توی این پاسخ، اول یه توضیح کامل و ساده درباره **Partial Prerendering (PPR)** توی Next.js بهت می‌دم و بعدش یه مثال واقعی توی یه پروژه بزرگ (لارج اسکیل) برات می‌زنم که بتونی کاربردش رو توی دنیای واقعی ببینی.

---

### Partial Prerendering (PPR) 
چیه؟
Partial Prerendering یه قابلیت آزمایشی (experimental) توی Next.js هست که از نسخه 14 معرفی شده. این مدل رندرینگ ترکیبی از مزایای رندر استاتیک (Static Rendering) و رندر دینامیک (Dynamic Rendering) رو توی یه مسیر (route) بهت می‌ده. ایده اصلی اینه که قسمت‌های استاتیک صفحه رو از قبل رندر کنه و سریع به کاربر نشون بده، در حالی که قسمت‌های دینامیک (مثل داده‌هایی که به کاربر یا درخواست بستگی دارن) به‌صورت جداگانه و به‌مرور بارگذاری بشن.

#### چطور کار می‌کنه؟
- موقع بیلد پروژه، Next.js یه پوسته استاتیک (static shell) از صفحه درست می‌کنه که شامل قسمت‌هایی هست که نیازی به داده‌های دینامیک ندارن.
- قسمت‌های دینامیک با استفاده از `Suspense` مشخص می‌شن و به‌صورت ناهمگام (asynchronously) بارگذاری می‌شن.
- وقتی کاربر صفحه رو باز می‌کنه، اول پوسته استاتیک رو می‌بینه (که سریع لود می‌شه) و بعد محتوای دینامیک به‌صورت استریم توی "سوراخ‌ها" (holes) پر می‌شه.

#### مزایا:
1. **سرعت اولیه بالا:** چون پوسته استاتیک از edge سرو می‌شه، کاربر سریع یه صفحه قابل مشاهده می‌بینه.
2. **انعطاف‌پذیری:** می‌تونی محتوای شخصی‌سازی‌شده (مثل سبد خرید یا پیشنهادات) رو دینامیک نگه داری.
3. **بهینه‌سازی SEO:** محتوای استاتیک برای موتورهای جستجو سریع‌تر در دسترسه.
4. **تجربه کاربری بهتر:** کاربر منتظر رندر کل صفحه نمی‌مونه.

#### محدودیت‌ها:
- هنوز آزمایشیه و برای پروژه‌های پروداکشن توصیه نمی‌شه.
- فقط توی نسخه‌های Canary Next.js در دسترسه.
- برای استفاده باید از `Suspense` درست استفاده کنی.

---

### مثال واقعی توی پروژه لارج اسکیل
#### سناریو: پلتفرم فروش آنلاین با میلیون‌ها کاربر
فرض کن داری یه وب‌سایت فروشگاهی بزرگ مثل دیجی‌کالا یا آمازون رو با Next.js می‌سازی. توی صفحه محصول (Product Detail Page)، این چالش‌ها رو داری:
- اطلاعات ثابت محصول (مثل نام، توضیحات، تصاویر) باید سریع لود بشن و برای SEO بهینه باشن.
- اطلاعات دینامیک (مثل موجودی انبار، قیمت لحظه‌ای، نظرات کاربران، پیشنهادات شخصی‌سازی‌شده) به کاربر و موقعیتش بستگی دارن و باید از سرور فچ بشن.
- سایت باید برای میلیون‌ها کاربر با درخواست‌های همزمان مقیاس‌پذیر باشه.

بدون PPR، یا باید کل صفحه رو استاتیک کنی (که دینامیک بودن رو از دست می‌دی) یا کل صفحه رو دینامیک کنی (که سرعت اولیه کم می‌شه). با PPR می‌تونی این دو رو ترکیب کنی.

#### پیاده‌سازی با PPR
##### 1. تنظیمات اولیه
توی فایل `next.config.js` باید PPR رو فعال کنی:
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    ppr: "incremental", // فعال‌سازی تدریجی PPR
  },
};

export default nextConfig;
```

##### 2. کد صفحه محصول
فرض کن این ساختار رو داری:
- **قسمت استاتیک:** نام محصول، توضیحات، تصاویر.
- **قسمت دینامیک:** موجودی انبار، قیمت لحظه‌ای، نظرات کاربران.

```jsx
// app/product/[id]/page.js
import { Suspense } from "react";

// فعال‌سازی PPR برای این مسیر
export const experimental_ppr = true;

// شبیه‌سازی فچ داده استاتیک (می‌تونه از CMS باشه)
async function getProductStaticData(id) {
  return {
    id,
    name: `محصول ${id}`,
    description: "یه محصول فوق‌العاده با کیفیت بالا",
    image: "/static/product.jpg",
  };
}

// شبیه‌سازی فچ داده دینامیک (مثل API انبار یا نظرات)
async function getProductDynamicData(id) {
  await new Promise((resolve) => setTimeout(resolve, 1000)); // تاخیر مصنوعی
  return {
    stock: Math.floor(Math.random() * 100),
    price: Math.floor(Math.random() * 10000000) + 500000,
    reviews: [`نظر کاربر ۱ درباره محصول ${id}`, "نظر کاربر ۲"],
  };
}

// کامپوننت‌های جداگانه
function ProductStatic({ data }) {
  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.description}</p>
      <img src={data.image} alt={data.name} style={{ maxWidth: "300px" }} />
    </div>
  );
}

function ProductDynamic({ id }) {
  const data = getProductDynamicData(id); // این تابع await نمی‌خواد چون توی Suspenseه
  return (
    <div>
      <p>موجودی: {data.stock} عدد</p>
      <p>قیمت: {data.price.toLocaleString("fa-IR")} تومان</p>
      <ul>
        {data.reviews.map((review, index) => (
          <li key={index}>{review}</li>
        ))}
      </ul>
    </div>
  );
}

function ProductSkeleton() {
  return (
    <div>
      <p>در حال بارگذاری موجودی...</p>
      <p>در حال بارگذاری قیمت...</p>
      <p>در حال بارگذاری نظرات...</p>
    </div>
  );
}

// صفحه اصلی محصول
export default async function ProductPage({ params }) {
  const { id } = params;
  const staticData = await getProductStaticData(id);

  return (
    <div style={{ padding: "20px", fontFamily: "Vazir, Arial" }}>
      {/* قسمت استاتیک که سریع رندر می‌شه */}
      <ProductStatic data={staticData} />

      {/* قسمت دینامیک که با Suspense استریم می‌شه */}
      <Suspense fallback={<ProductSkeleton />}>
        <ProductDynamic id={id} />
      </Suspense>
    </div>
  );
}
```

---

### توضیحات مثال
#### چطور کار می‌کنه؟
1. **پوسته استاتیک:** وقتی کاربر وارد صفحه محصول می‌شه (مثلاً `/product/123`)، Next.js فوراً پوسته استاتیک (نام محصول، توضیحات، تصویر) رو از cache یا edge سرو می‌کنه. این باعث می‌شه Time to First Byte (TTFB) خیلی کم باشه.
2. **محتوای دینامیک:** توی همون درخواست HTTP، قسمت‌های دینامیک (موجودی، قیمت، نظرات) به‌صورت استریم از سرور رندر می‌شن و توی "سوراخ" مشخص‌شده توسط `Suspense` پر می‌شن.
3. **Fallback:** تا وقتی داده‌های دینامیک آماده بشن، کاربر یه اسکلتون (لودر) می‌بینه که تجربه کاربری رو خراب نمی‌کنه.

#### چرا لارج اسکیل؟
- **مقیاس‌پذیری:** توی یه پلتفرم با میلیون‌ها کاربر، سرو کردن پوسته استاتیک از edge (مثل CDNهای Vercel) بار سرور رو کم می‌کنه و درخواست‌های دینامیک رو فقط برای داده‌های ضروری نگه می‌داره.
- **شخصی‌سازی:** می‌تونی داده‌های دینامیک رو بر اساس کوکی‌ها، موقعیت جغرافیایی یا پروفایل کاربر فچ کنی (مثلاً پیشنهادات شخصی‌شده).
- **SEO و عملکرد:** موتورهای جستجو محتوای استاتیک رو سریع می‌بینن و کاربرا هم تجربه سریعی دارن.

#### بهینه‌سازی‌های ممکن:
- **ISR (Incremental Static Regeneration):** می‌تونی پوسته استاتیک رو با ISR ترکیب کنی تا هر چند ساعت آپدیت بشه.
- **چندین Suspense:** اگه بخوای موجودی، قیمت و نظرات جداگانه استریم بشن، می‌تونی هر کدوم رو توی یه `Suspense` بذاری.
- **داده‌های واقعی:** به جای شبیه‌سازی، از یه API واقعی (مثل GraphQL یا REST) داده بگیری.

---

### جمع‌بندی
Partial Prerendering توی Next.js یه راه‌حل هوشمندانه‌ست برای پروژه‌های بزرگ که هم سرعت می‌خوان و هم انعطاف‌پذیری. توی سناریوی فروشگاهی که گفتم، این قابلیت بهت اجازه می‌ده یه تجربه کاربری سریع و روان بسازی، در حالی که داده‌های دینامیک رو بهینه مدیریت می‌کنی. چون هنوز آزمایشیه، پیشنهاد می‌کنم توی پروژه‌های تست امتحانش کنی و اگه به پروداکشن نزدیک شد، ازش استفاده کنی.

اگه سوالی داری یا می‌خوای بخش خاصی رو بیشتر توضیح بدم، بگو!