
##  مفهوم PPR: یک ویژگی جدید و آزمایشی است که در Next.js 15 معرفی شده است .

1. معرفی PPR:
Partial Pre-rendering به شما امکان می‌دهد اجزای استاتیک و پویا را در یک مسیر (route) ترکیب کنید .
2. هدف PPR:
هدف اصلی PPR، ترکیب مزایای رندرینگ استاتیک و پویا است .
1. نحوه کارکرد:

2. در زمان ساخت (build time)، Next.js تا حد امکان از مسیر را پیش‌رندر می‌کند.
3. اگر کد پویا تشخیص داده شود (مانند خواندن از درخواست ورودی)، می‌توانید کامپوننت مربوطه را با یک مرز React Suspense بپیچید .



4. پذیرش تدریجی در Next.js 15:

5. برای استفاده از PPR، باید گزینه `ppr` را در `next.config.js` به `'incremental'` تنظیم کنید.
6. همچنین باید گزینه پیکربندی مسیر `experimental_ppr` را در بالای فایل صادر کنید .



7. نحوه پیکربندی:
در `next.config.js`:

```javascript
const nextConfig = {
  experimental: {
    ppr: 'incremental',
  },
};

export default nextConfig;
```

در فایل مسیر (مثلاً `app/page.tsx`):

```javascript
export const experimental_ppr = true;

export default function Page() {
  // ...
}
```


8. نکات مهم:

9. مسیرهایی که `experimental_ppr` ندارند، به طور پیش‌فرض از PPR استفاده نمی‌کنند.
10. `experimental_ppr` برای تمام فرزندان بخش مسیر اعمال می‌شود، از جمله لایه‌ها و صفحات تودرتو.
11. برای غیرفعال کردن PPR برای بخش‌های فرزند، می‌توانید `experimental_ppr` را در بخش فرزند به `false` تنظیم کنید .



12. وضعیت فعلی:
PPR هنوز یک ویژگی آزمایشی است و ممکن است تغییر کند. برای استفاده در محیط تولید توصیه نمی‌شود .


بسیار خوب، اجازه دهید جزئیات بیشتری در مورد Partial Pre-rendering (PPR) در Next.js 15 ارائه دهم:

13. مزایای PPR:

14. بهبود عملکرد: با ترکیب رندرینگ استاتیک و پویا، PPR می‌تواند زمان بارگذاری اولیه را کاهش دهد .
15. انعطاف‌پذیری: به شما امکان می‌دهد بخش‌های استاتیک و پویا را در یک صفحه داشته باشید .



16. نحوه کار PPR در پشت صحنه:

17. در زمان ساخت، Next.js یک نسخه استاتیک از صفحه را ایجاد می‌کند.
18. برای بخش‌های پویا، یک placeholder در HTML اولیه قرار می‌دهد.
19. در زمان اجرا، بخش‌های پویا به صورت تدریجی بارگذاری و رندر می‌شوند .



20. استفاده از Suspense با PPR:
برای بخش‌های پویا، از Suspense استفاده می‌کنید:

```javascriptreact
import { Suspense } from 'react';
import { DynamicComponent } from './DynamicComponent';

export const experimental_ppr = true;

export default function Page() {
  return (
    <>
      <h1>This will be pre-rendered</h1>
      <Suspense fallback={<p>Loading...</p>}>
        <DynamicComponent />
      </Suspense>
    </>
  );
}
```


21. محدودیت‌ها و نکات:

22. PPR فقط در حالت تولید (production) کار می‌کند، نه در حالت توسعه (development) .
23. در حال حاضر، PPR با برخی ویژگی‌های Next.js مانند `getStaticProps` و `getServerSideProps` سازگار نیست .



24. مقایسه با رویکردهای قبلی:

25. برخلاف SSG یا SSR، PPR اجازه می‌دهد بخش‌هایی از صفحه استاتیک و بخش‌های دیگر پویا باشند .
26. این رویکرد می‌تواند جایگزینی برای ISR (Incremental Static Regeneration) در برخی موارد باشد .



27. بهینه‌سازی عملکرد:

28. PPR می‌تواند به طور قابل توجهی Time to First Byte (TTFB) را بهبود بخشد، زیرا بخش‌های استاتیک فوراً ارسال می‌شوند .
29. بخش‌های پویا می‌توانند به صورت موازی بارگذاری شوند، که باعث بهبود عملکرد کلی می‌شود .



30. دیباگ کردن PPR:

31. Next.js ابزارهایی برای دیباگ PPR ارائه می‌دهد، از جمله لاگ‌های خاص که نشان می‌دهند کدام بخش‌ها به صورت استاتیک و کدام به صورت پویا رندر شده‌اند .



32. آینده PPR:

33. انتظار می‌رود که PPR در نسخه‌های آینده Next.js بهبود یابد و ویژگی‌های بیشتری به آن اضافه شود .


==========================================================

با توجه به اینکه شما علاقه‌مند به اطلاعات بیشتر هستید، اجازه دهید به برخی از جنبه‌های پیشرفته‌تر و کاربردی‌تر Partial Pre-rendering (PPR) در Next.js 15 بپردازیم:


1. استراتژی‌های بهینه‌سازی با PPR:

2. تقسیم‌بندی محتوا: محتوای استاتیک را در بالای صفحه قرار دهید تا First Contentful Paint (FCP) را بهبود بخشید .
3. استفاده از Streaming SSR: PPR را می‌توان با Streaming SSR ترکیب کرد تا عملکرد را بیشتر بهبود بخشید .



4. مدیریت حالت (State Management) با PPR:

5. برای کامپوننت‌های پویا، می‌توانید از هوک‌های React مانند `useState` و `useEffect` استفاده کنید.
6. برای مدیریت حالت در سطح برنامه، می‌توانید از ابزارهایی مانند Redux یا Recoil استفاده کنید که با PPR سازگار هستند.



7. کار با API Routes و PPR:

8. API Routes همچنان به صورت پویا کار می‌کنند و می‌توانند با کامپوننت‌های پویا در PPR استفاده شوند.
9. می‌توانید از `fetch` در کامپوننت‌های سرور برای درخواست‌های API استفاده کنید .



10. SEO و PPR:

11. بخش‌های استاتیک صفحه برای موتورهای جستجو قابل مشاهده خواهند بود.
12. برای محتوای پویا، می‌توانید از تکنیک‌های مانند Dynamic Rendering استفاده کنید تا SEO را بهبود بخشید.



13. تست و CI/CD با PPR:

14. تست‌های واحد: کامپوننت‌های استاتیک و پویا را جداگانه تست کنید.
15. تست‌های یکپارچگی: اطمینان حاصل کنید که کامپوننت‌های استاتیک و پویا به درستی با هم کار می‌کنند.
16. در CI/CD، اطمینان حاصل کنید که PPR در محیط تولید به درستی فعال شده است.



17. مدیریت خطا در PPR:

18. استفاده از Error Boundaries برای مدیریت خطاهای کامپوننت‌های پویا:


```javascriptreact
import { ErrorBoundary } from 'react-error-boundary';

export default function Page() {
  return (
    <>
      <StaticComponent />
      <ErrorBoundary fallback={<ErrorFallback />}>
        <Suspense fallback={<Loading />}>
          <DynamicComponent />
        </Suspense>
      </ErrorBoundary>
    </>
  );
}
```


19. استفاده از PPR با TypeScript:

20. TypeScript با PPR سازگار است. می‌توانید از type annotations برای کامپوننت‌های استاتیک و پویا استفاده کنید.



21. پرفورمنس مانیتورینگ با PPR:

22. استفاده از ابزارهای مانند Lighthouse و Web Vitals برای اندازه‌گیری تأثیر PPR بر عملکرد سایت.
23. مانیتور کردن متریک‌های خاص مانند Time to Interactive (TTI) و Largest Contentful Paint (LCP).



24. استفاده از PPR با CDN‌ها:


25. PPR با CDN‌ها سازگار است. بخش‌های استاتیک می‌توانند در edge caches ذخیره شوند، در حالی که بخش‌های پویا از سرور اصلی درخواست می‌شوند.
