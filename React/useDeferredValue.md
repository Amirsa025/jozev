
هوک `useDeferredValue` یکی از ابزارهای قدرتمند React هست که برای بهینه‌سازی عملکرد (performance optimization) توی رابط‌های کاربری استفاده می‌شه. توی این پاسخ، همه‌چیز رو درباره این هوک به زبون ساده و با جزئیات کامل توضیح می‌دم تا بتونی درک عمیقی ازش داشته باشی و توی سناریوهای واقعی ازش استفاده کنی.

---

### هوک `useDeferredValue` چیه؟
`useDeferredValue` 
یه هوک در React هست که بهت اجازه می‌ده یه مقدار رو "به تعویق بندازی" (defer کنی). 
این یعنی React یه نسخه "قدیمی‌تر" یا "کم اهمیت‌تر" از اون مقدار رو نگه می‌داره و فقط وقتی که رندرهای مهم‌تر (مثل پاسخ به ورودی کاربر) تموم بشه، مقدار جدید رو اعمال می‌کنه. این کار باعث می‌شه رابط کاربریت سریع‌تر و پاسخ‌گوتر بمونه، مخصوصاً وقتی داری با عملیات سنگین مثل رندر لیست‌های بزرگ یا به‌روزرسانی‌های پیچیده سروکار داری.

#### امضا (Signature):
```javascript
const deferredValue = useDeferredValue(value);
```
- `value`: مقداری که می‌خوای به تعویق بندازی (می‌تونه هر چیزی باشه: رشته، عدد، آرایه، آبجکت و غیره).
- `deferredValue`: نسخه به‌تعویق‌افتاده همون مقدار که React به مرور زمان آپدیتش می‌کنه.

---

### چرا باید از `useDeferredValue` استفاده کنیم؟
وقتی یه ورودی کاربر (مثل تایپ توی یه فیلد جستجو) باعث رندر دوباره کامپوننت می‌شه و این رندر سنگین باشه (مثلاً فیلتر کردن یه لیست بزرگ)، ممکنه رابط کاربری کند بشه و کاربر احساس کنه برنامه لگ داره. `useDeferredValue` این مشکل رو با جدا کردن "به‌روزرسانی فوری" (مثل نشون دادن چیزی که کاربر تایپ کرده) از "به‌روزرسانی‌های سنگین‌تر" (مثل فیلتر کردن لیست) حل می‌کنه.

#### موارد استفاده اصلی:
1. **بهبود پاسخ‌گویی UI:** وقتی کاربر چیزی تایپ می‌کنه، فوراً ورودی رو نشون می‌دی، ولی نتایج سنگین‌تر (مثل جستجو) رو به تعویق می‌ندازی.
2. **مدیریت رندرهای سنگین:** برای سناریوهایی مثل رندر لیست‌های بزرگ، نمودارها یا محاسبات پیچیده.
3. **جایگزین debounce دستی:** به جای اینکه خودت با `setTimeout` تاخیر بذاری، React این کار رو به صورت بهینه برات انجام می‌ده.

---

### چطور کار می‌کنه؟
- وقتی `value` تغییر می‌کنه، `deferredValue` فوراً آپدیت نمی‌شه. React اول رندرهای "فوری" (مثل به‌روزرسانی ورودی کاربر) رو انجام می‌ده و بعد توی یه رندر جداگانه (با اولویت پایین‌تر) مقدار `deferredValue` رو به‌روزرسانی می‌کنه.
- این رفتار از سیستم Concurrent Rendering توی React استفاده می‌کنه که تسک‌ها رو اولویت‌بندی می‌کنه.

#### نکته مهم:
`useDeferredValue` فقط توی نسخه‌های React که از Concurrent Rendering پشتیبانی می‌کنن (مثل React 18 و 19) معنی داره. اگه از نسخه قدیمی‌تر استفاده می‌کنی، این هوک کار خاصی نمی‌کنه و مقدار اولیه رو برمی‌گردونه.

---

### مثال کاربردی
#### سناریو:
یه فیلد جستجو داری که کاربر باهاش توی یه لیست بزرگ (مثلاً ۱۰,۰۰۰ آیتم) سرچ می‌کنه. بدون بهینه‌سازی، هر بار که کاربر تایپ می‌کنه، رندر لیست کند می‌شه و UI لگ می‌زنه.

#### کد:
```jsx
import { useState, useDeferredValue } from "react";

function SearchList() {
  const [query, setQuery] = useState("");
  const deferredQuery = useDeferredValue(query);

  // لیست بزرگ فرضی
  const items = Array.from({ length: 10000 }, (_, i) => `آیتم ${i}`);

  // فیلتر کردن لیست بر اساس deferredQuery
  const filteredItems = items.filter((item) =>
    item.includes(deferredQuery)
  );

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="جستجو کن..."
      />
      <p>جستجوی فعلی: {query}</p>
      <ul>
        {filteredItems.slice(0, 100).map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

export default SearchList;
```

#### توضیح کارکرد:
1. **ورودی فوری (`query`):** وقتی کاربر تایپ می‌کنه، `query` فوراً آپدیت می‌شه و توی `<input>` و `<p>` نشون داده می‌شه. این کار سریع انجام می‌شه چون فقط یه رشته ساده‌ست.
2. **فیلتر به‌تعویق‌افتاده (`deferredQuery`):** عملیات سنگین‌تر (فیلتر کردن لیست ۱۰,۰۰۰ تایی) با `deferredQuery` انجام می‌شه. React این کار رو به تعویق می‌ندازه تا تایپ کاربر مختل نشه.
3. **نتیجه:** کاربر حس می‌کنه UI پاسخ‌گوئه، چون ورودی فوراً نشون داده می‌شه و نتایج جستجو یه کم بعد ظاهر می‌شن.

---

### تفاوت با `useTransition`
`useDeferredValue` و `useTransition` هر دو برای مدیریت رندرهای سنگین توی React استفاده می‌شن، ولی فرق‌هایی دارن:
- **`useDeferredValue`:** یه مقدار مشخص (مثل `query`) رو به تعویق می‌ندازه و بهت نسخه deferred اون رو می‌ده. برای سناریوهایی که فقط یه مقدار داری و می‌خوای بهینه‌اش کنی عالیه.
- **`useTransition`:** بهت اجازه می‌ده یه به‌روزرسانی خاص (مثل `setState`) رو به‌عنوان "کم اهمیت" علامت‌گذاری کنی و وضعیت "در حال انتظار" (pending) رو هم مدیریت کنی. برای وقتی که نیاز به کنترل بیشتر داری مناسبه.

#### مثال مقایسه:
- با `useDeferredValue`: بالا رو نگاه کن.
- با `useTransition`:
```jsx
import { useState, useTransition } from "react";

function SearchListWithTransition() {
  const [query, setQuery] = useState("");
  const [filteredItems, setFilteredItems] = useState([]);
  const [isPending, startTransition] = useTransition();

  const items = Array.from({ length: 10000 }, (_, i) => `آیتم ${i}`);

  const handleChange = (e) => {
    const newQuery = e.target.value;
    setQuery(newQuery);
    startTransition(() => {
      setFilteredItems(items.filter((item) => item.includes(newQuery)));
    });
  };

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={handleChange}
        placeholder="جستجو کن..."
      />
      {isPending && <p>در حال بارگذاری...</p>}
      <ul>
        {filteredItems.slice(0, 100).map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
}
```
**فرق:** `useTransition` بهت `isPending` می‌ده تا وضعیت در حال انتظار رو نشون بدی، ولی `useDeferredValue` ساده‌تره و فقط مقدار رو مدیریت می‌کنه.

---

### نکات مهم و بهترین روش‌ها
1. **چه موقع استفاده کنیم؟**
   - وقتی یه مقدار (مثل ورودی کاربر) باعث رندر سنگین می‌شه.
   - وقتی نمی‌خوای کاربر حس کنه UI کند شده.

2. **چه موقع استفاده نکنیم؟**
   - اگه رندرت سبک باشه و نیازی به بهینه‌سازی نباشه.
   - اگه نیاز به مدیریت دستی وضعیت "در حال انتظار" داری (اینجا `useTransition` بهتره).

3. **ترکیب با Suspense:**
   اگه داری با داده‌های ناهمگام (مثل فچ کردن از API) کار می‌کنی، می‌تونی `useDeferredValue` رو با `Suspense` ترکیب کنی:
   ```jsx
   const deferredQuery = useDeferredValue(query);
   const data = use(fetchData(deferredQuery)); // با هوک use
   ```

4. **محدودیت‌ها:**
   - توی رندرهای همزمان (Concurrent) بهتر کار می‌کنه. اگه پروژه‌ات از رندر همزمان پشتیبانی نمی‌کنه، تاثیرش کمتره.
   - مقدار اولیه `deferredValue` همون مقدار اولیه `value` هست و تا رندر بعدی تغییر نمی‌کنه.

---

### سناریوهای واقعی
1. **جستجوی زنده (Live Search):** مثل مثال بالا، برای فیلتر کردن لیست‌ها یا جدول‌ها.
2. **نمایش پیش‌نمایش:** وقتی کاربر یه متن تایپ می‌کنه و می‌خوای یه پیش‌نمایش سنگین (مثل رندر Markdown) نشون بدی.
3. **فیلترهای پیچیده:** توی داشبوردهای داده که فیلتر کردنشون زمان‌بره.

---

### جمع‌بندی
`useDeferredValue` یه ابزار ساده ولی قدرتمنده که بهت کمک می‌کنه تعادل بین پاسخ‌گویی و عملکرد رو حفظ کنی. با جدا کردن به‌روزرسانی‌های فوری از کارهای سنگین‌تر، باعث می‌شه کاربرات تجربه بهتری داشته باشن. اگه سوالی داری یا می‌خوای مثال دیگه‌ای برات بزنم، بگو تا بیشتر کمکت کنم!