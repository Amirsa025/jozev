به‌عنوان یه مصاحبه‌کننده ارشد فرانت‌اند که می‌خوام توانایی‌های کارجو رو توی کار با حلقه‌ها، ساختارهای داده مثل Objectها و آرایه‌ها، و حل مسائل واقعی ارزیابی کنم، سؤالم رو طوری طراحی می‌کنم که هم مهارت‌های پایه‌ای و هم توانایی حل مسئله پیشرفته رو بسنجم. اینجا چند سؤال سخت و کاربردی پیشنهاد می‌دم که می‌تونی توی مصاحبه بپرسی، به همراه جواب‌های پیشنهادی که کارجو می‌تونه بده. این سؤال‌ها به شکلی هستن که هم جنبه تئوری دارن و هم عملی، و هم می‌تونن توانایی کارجو رو توی سناریوهای واقعی فرانت‌اند نشون بدن.

---

## **سؤالات سخت برای مصاحبه**

### **سؤال ۱: طراحی یه تابع برای ادغام اشیاء با مدیریت داده‌های تودرتو**
**صورت سؤال:**
فرض کن یه تابع به اسم `deepMerge` داری که باید دو یا چند شیء رو با هم ادغام کنه، اما اگه یه کلید توی هر دو شیء وجود داشته باشه و مقدارش خودش یه شیء باشه، باید به‌صورت بازگشتی (recursive) ادغام بشن. این تابع رو بنویس و توضیح بده چرا از این روش استفاده کردی. بعدش توضیح بده توی یه سناریوی واقعی فرانت‌اند (مثل مدیریت state توی React) چطور می‌تونی ازش استفاده کنی.

**چالش:**
- مدیریت بازگشتی داده‌های تودرتو.
- پرفورمنس و جلوگیری از باگ (مثلاً وقتی مقدار null یا undefined باشه).

---

**جواب پیشنهادی کارجو:**

**الف) کد تابع:**
```javascript
function deepMerge(...objects) {
  const isObject = obj => obj && typeof obj === 'object' && !Array.isArray(obj);

  return objects.reduce((result, current) => {
    if (!current) return result;

    for (const key in current) {
      if (isObject(current[key]) && isObject(result[key])) {
        result[key] = deepMerge(result[key], current[key]);
      } else {
        result[key] = current[key];
      }
    }
    return result;
  }, {});
}

// تست
const obj1 = { a: 1, b: { x: 10, y: 20 } };
const obj2 = { b: { y: 30, z: 40 }, c: 3 };
console.log(deepMerge(obj1, obj2));
// خروجی: { a: 1, b: { x: 10, y: 30, z: 40 }, c: 3 }
```

**ب) توضیحات:**
- از `reduce` استفاده کردم تا بتونم چندین شیء رو با هم ادغام کنم.
- تابع `isObject` رو تعریف کردم تا مطمئن بشم فقط روی اشیاء (نه آرایه‌ها) کار می‌کنم.
- برای هر کلید، چک می‌کنم که آیا مقدارش یه شیء هست یا نه. اگه هست، به صورت بازگشتی ادغامش می‌کنم.
- این روش از تغییر مستقیم اشیاء ورودی جلوگیری می‌کنه و یه شیء جدید برمی‌گردونه (immutability).

**ج) کاربرد توی فرانت‌اند:**
توی React، فرض کن یه فرم داری که کاربر داده‌ها رو مرحله به مرحله وارد می‌کنه. می‌تونی از این تابع برای ادغام stateهای مختلف استفاده کنی:
```javascript
const initialState = { user: { name: "علی" }, settings: { theme: "dark" } };
const updatedState = { user: { age: 30 } };
const newState = deepMerge(initialState, updatedState);
// خروجی: { user: { name: "علی", age: 30 }, settings: { theme: "dark" } }
setState(newState);
```

**چرا این جواب خوبه؟**
- نشون می‌ده کارجو با مفاهیم بازگشتی، immutability و کاربردهای واقعی آشنا هست.
- کدش هم تمیزه و هم پرفورمنس رو در نظر گرفته.

---

### **سؤال ۲: تابع برای فیلتر کردن آرایه‌های بزرگ با چندین شرط**
**صورت سؤال:**
یه تابع بنویس که یه آرایه بزرگ از اشیاء رو فیلتر کنه و بتونه چندین شرط رو با هم ترکیب کنه (مثلاً AND یا OR). مثلاً یه لیست از محصولات داری و می‌خوای محصولاتی که قیمتشون بین ۱۰۰ تا ۵۰۰ هست و توی یه دسته‌بندی خاص هستن رو فیلتر کنی. از چه حلقه‌ای استفاده می‌کنی و چرا؟ اگه بخوای این تابع رو توی یه اپلیکیشن فرانت‌اند با پرفورمنس بالا (مثل یه جدول بزرگ) استفاده کنی، چه نکاتی رو رعایت می‌کنی؟

**چالش:**
- مدیریت شرط‌های پیچیده.
- بهینه‌سازی برای داده‌های بزرگ.

---

**جواب پیشنهادی کارجو:**

**الف) کد تابع:**
```javascript
function filterItems(items, filters, logic = "AND") {
  return items.filter(item => {
    const conditions = Object.entries(filters).map(([key, condition]) => {
      if (typeof condition === "function") {
        return condition(item[key]);
      }
      return item[key] === condition;
    });

    return logic === "AND"
      ? conditions.every(Boolean)
      : conditions.some(Boolean);
  });
}

// تست
const products = [
  { id: 1, name: "لپتاپ", price: 300, category: "الکترونیک" },
  { id: 2, name: "کتاب", price: 50, category: "کتاب" },
  { id: 3, name: "تلویزیون", price: 400, category: "الکترونیک" }
];

const filters = {
  price: price => price >= 100 && price <= 500,
  category: "الکترونیک"
};

const filtered = filterItems(products, filters, "AND");
console.log(filtered);
// خروجی: [{ id: 1, name: "لپتاپ", price: 300, category: "الکترونیک" }, { id: 3, name: "تلویزیون", price: 400, category: "الکترونیک" }]
```

**ب) توضیحات:**
- از متد `filter` استفاده کردم چون برای فیلتر کردن آرایه‌ها بهینه‌ست و خواناترین روشه.
- شرط‌ها رو به صورت یه شیء می‌گیرم تا انعطاف‌پذیر باشه. هر شرط می‌تونه یا یه مقدار ساده باشه (برای مقایسه مستقیم) یا یه تابع (برای شرط‌های پیچیده).
- از `every` و `some` برای ترکیب شرط‌ها با منطق AND/OR استفاده کردم.
- اگه داده خیلی بزرگ باشه، می‌تونم از Web Worker یا تابع رو به صورت Generator پیاده‌سازی کنم تا پردازش بهینه‌تر بشه.

**ج) نکات پرفورمنس توی فرانت‌اند:**
- اگه توی یه جدول بزرگ استفاده می‌کنم، از **memoization** (مثل `useMemo` توی React) استفاده می‌کنم تا فیلتر زدن دوباره انجام نشه:
  ```javascript
  const filteredProducts = useMemo(() => filterItems(products, filters), [products, filters]);
  ```
- برای جلوگیری از رندرهای اضافی، مطمئن می‌شم که فقط وقتی داده یا فیلترها تغییر می‌کنن، تابع اجرا بشه.
- اگه تعداد آیتم‌ها خیلی زیاده، می‌تونم از **pagination** یا **lazy loading** استفاده کنم.

**چرا این جواب خوبه؟**
- کارجو نشون می‌ده که هم با متدهای مدرن جاوااسکریپت آشناست، هم به پرفورمنس و کاربردهای واقعی فکر می‌کنه.

---

### **سؤال ۳: جمع‌آوری داده‌های فرم با ساختار پویا**
**صورت سؤال:**
فرض کن یه فرم داری که فیلدهاش به صورت پویا از یه API میاد و هر فیلد ممکنه یه مقدار ساده (مثل رشته) یا یه شیء تودرتو (مثل آدرس با زیرفیلدهای شهر و خیابان) باشه. یه تابع بنویس که داده‌های این فرم رو جمع‌آوری کنه و یه شیء تمیز و بدون مقدار خالی برگردونه. از چه حلقه‌ای استفاده می‌کنی و چرا؟ اگه بخوای این داده رو به سرور بفرستی، چه نکاتی رو رعایت می‌کنی؟

**چالش:**
- مدیریت داده‌های تودرتو و پویا.
- حذف مقادیر خالی یا نامعتبر.

---

**جواب پیشنهادی کارجو:**

**الف) کد تابع:**
```javascript
function collectFormData(formData) {
  const result = {};

  function traverse(obj, target, prefix = "") {
    for (const key in obj) {
      const value = obj[key];
      const newKey = prefix ? `${prefix}.${key}` : key;

      if (value && typeof value === "object" && !Array.isArray(value)) {
        traverse(value, target, newKey);
      } else if (value !== "" && value != null) {
        target[newKey] = value;
      }
    }
  }

  traverse(formData, result);
  return result;
}

// تست
const formData = {
  name: "علی",
  email: "",
  address: {
    city: "تهران",
    street: "",
    zip: "۱۲۳۴۵"
  }
};

console.log(collectFormData(formData));
// خروجی: { name: "علی", "address.city": "تهران", "address.zip": "۱۲۳۴۵" }
```

**ب) توضیحات:**
- از `for...in` استفاده کردم چون با اشیاء کار می‌کنم و نیاز دارم روی کلیدها تکرار کنم.
- یه تابع بازگشتی (`traverse`) نوشتم تا بتونم داده‌های تودرتو رو مدیریت کنم.
- برای کلیدهای تودرتو، از یه فرمت نقطه‌دار (dot notation) استفاده کردم تا ساختار واضح باشه.
- مقادیر خالی یا `null` رو حذف کردم تا داده تمیز باشه.

**ج) نکات برای ارسال به سرور:**
- قبل از ارسال، یه اعتبارسنجی می‌کنم که داده‌های ضروری (مثل `name`) وجود داشته باشن.
- اگه API فرمت خاصی می‌خواد (مثلاً ساختار تودرتو به جای dot notation)، یه تابع اضافی برای تبدیل می‌نویسم.
- از `try/catch` توی درخواست HTTP استفاده می‌کنم تا خطاها رو مدیریت کنم:
  ```javascript
  try {
    await fetch("/api/submit", {
      method: "POST",
      body: JSON.stringify(collectFormData(formData)),
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    console.error("خطا در ارسال:", error);
  }
  ```

**چرا این جواب خوبه؟**
- کارجو توانایی کار با داده‌های پویا و تودرتو رو نشون می‌ده.
- به نکات عملی مثل اعتبارسنجی و مدیریت خطا توجه داره.

---

## **نکات برای مصاحبه‌کننده**
1. **سطح کارجو رو در نظر بگیر:** اگه کارجو جونیوره، سؤال رو ساده‌تر کن (مثلاً فقط ادغام دو شیء ساده). اگه سنیوره، سؤالم رو پیچیده‌تر می‌کنم.
2. **تمرکز روی توضیحات:** از کارجو بخواه که کدش رو توضیح بده و بگه چرا یه حلقه خاص رو انتخاب کرده.
3. **سناریوهای واقعی:** سؤالم رو با مثال‌های واقعی (مثل فرم، جدول یا رندر لیست) می‌پرسم تا ببینم کارجو چطور مسائل واقعی رو حل می‌کنه.
4. **پرفورمنس و مقیاس‌پذیری:** ازشون بپرس چطور کدشون رو برای داده‌های بزرگ بهینه می‌کنن.

---

## **جمع‌بندی**
این سؤال‌ها بهت کمک می‌کن توانایی کارجو رو توی کار با Objectها، حلقه‌ها و سناریوهای واقعی فرانت‌اند ببینی. جواب‌های پیشنهادی هم به کارجو کمک می‌کن که با ساختار درست و منطق مناسب مسئله رو حل کنه. اگه می‌خوای سؤالم رو توی یه حوزه خاص (مثلاً React یا TypeScript) عمیق‌تر کنم، بگو!